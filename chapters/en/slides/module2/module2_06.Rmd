---
params:
  dynamictitle: "module2_06"
title: "`r params$dynamictitle`"
output: 
  md_document:
    variant: gfm
---


```{r setup, include=FALSE}
## DO NOT FORGET TO CHANGE THIS ACCORDINGLY 
library(rmarkdown)
# MAke sure you are updating your title 
knitr::opts_chunk$set(echo = TRUE,
                      base.dir = ".", 
                      base.url = "/",
                      fig.path = paste("../static/module2/", params$dynamictitle,"/", sep = ""))

knitr_opts <- knitr_options( opts_knit = NULL,
                             opts_chunk = NULL,
                             knit_hooks = NULL,
                             opts_hooks = NULL,
                             opts_template = NULL)
md_document_custom <- md_document(variant = "gfm")
output_format(knitr = knitr_opts,
              pandoc = NULL,
              base_format = md_document_custom)
library(reticulate)

```


```{python include=FALSE}
import pandas as pd
import numpy as np
pd.set_option('display.width', 350)

np.set_printoptions(linewidth=400)

pd.set_option('display.max_columns', 15)
pd.set_option('display.max_rows', 20)

df = pd.read_csv('cereal.csv', index_col=0)
```


type: slides

# Reading arguments

Notes: <br>

---

## Arguments 

Here, we are going to introduce different arguments for `pd.read_csv()` and `pd.read_excel()`: 

- `index_col`
- `header`
- `nrows`
- `usecols`

If you wish to know more, you can find the documentation at the following links:

- <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.read_csv.html" target="_blank">`pd.read_csv()`</a>
- <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.read_excel.html" target="_blank">`pd.read_excel()`</a>


Notes: 

When we load in our data we use different arguments to make sure it's organized how we want it. 

`delimiter` is an argument we have already discussed that instructs on how to separate each value in the data. 

This is only the tip of the iceberg.  There are many others that are helpful when reading in our data. 

---

## index_col

```{python}
df = pd.read_csv('cereal.csv', index_col="name")
df.head()
```


```{python}
df = pd.read_csv('cereal.csv', index_col=0)
df.head()
```



Notes: 
`index_col` is an argument that indicates which column will be acting as the index label. In most of the cases we have encountered, we did not use this argument.  For the majority of the data we have seen, each dataframe's index was just a column of with a unique number for each row.    

We can, however, specify a column to be the index. It's in our best interest that the column we choose have unique values.   
For our `cereal.csv` let's specify the `name` column as our index. 

The `index_col` argument also take in positions. the `name` column in our data in in the 0th position so we can also specify the index like we show here. 


---

## header

<img src='/module2/header_textedit.png'  alt="404 image"/>


Notes:

We have been lucky up until now that all the data we have loaded in has been particularly straightforward.  Sometimes with data, there are a few lines of text explaining important points about the file.  We do not want to include this in our dataframe and therefore we need to specify exactly when our dataframe begins.  This is where `header` comes in. 
  
Take a look at the <a href="https://github.com/UBC-MDS/MCL-DSCI-511-programming-in-python/blob/master/slides/candybars-h.csv" target="_blank">`candybars-h.csv` file </a> as an example.

If we look at the data with a regular text editor, the data doesn't start until the 3rd line which would be the equivalent of position 2 (since we begin at index 0).


---

```{python}
candybars = pd.read_csv('candybars-h.csv')
candybars
```


Notes: 

If we load this data without any arguments, we get this as the output.

We see that there are no clear column names and things are in quite a disarray. 

---


```{python}
candybars = pd.read_csv('candybars-h.csv', header=2)
candybars
```



Notes: 

We use `header=2` to indicate where our dataframe begins (2 being the index position or the row that contains the column labels).

That's looking much better. 

---

## nrows

```{python}
candybars = pd.read_csv('candybars.csv', nrows=7)
candybars
```


Notes: 

`nrows` is an argument that is useful when you only want to load in a slice of the dataframe. 

Perhaps the file you have is large and you only want a sample of it.  `nrows` will limit the number of rows from the file to read in. 

Take our regular `candybar.csv` file, where we only want 7 of the rows of data. 

---

## usecols


```{python}
candybars = pd.read_csv('candybars.csv', usecols=[0, 1, 10])
candybars
```

Notes: 

Similarly to how `nrows` specifies how many rows to read in, `usecols` selects which columns to load from the data.  Perhaps the only columns relevant to our analysis are the columns `name`, `weight` and `available_canada_america`.  We can forgo the other columns when reading the data in. 

In a similar way to selecting columns using `.iloc[]`, we put the desired column index positions in square brackets for the argument. 

---


```{python}
candybars = pd.read_csv('candybars.csv', usecols=['name', 'weight', 'available_canada_america'])
candybars
```



Notes: 

The `usecols` argument accepts either index positions or labels so we could also use the column names in square brackets.

---

# Letâ€™s apply what we learned!

Notes: 

<br>